---
title: "CARTO Helm Chart Secrets Management"
tags: ["helm", "secrets", "security", "kubernetes"]
description: "Comprehensive rules for managing secrets in CARTO Helm charts following enterprise security patterns and the dual-secret system architecture"
alwaysApply: true
---

# CARTO Helm Chart Secrets Management Rules

## Secret Architecture and System Design

### Dual-Secret System Structure
- **Platform Secrets (`cartoSecrets`)**: Shared across all components (instanceId, encryptionSecretKey, jwtApiSecret, litellmMasterKey)
- **Component Secrets (`appSecrets`)**: Component-specific secrets (googleMapsApiKey, importAwsAccessKeyId, bigqueryOauth2ClientSecret)
- Always separate sensitive data from non-sensitive configuration using distinct layers
- Follow the data flow: `values.yaml → _helpers.tpl → ConfigMaps/Secrets → Deployments → Containers`

### Secret Association System
- **ALWAYS** use the centralized `carto._utils.secretAssociation` function in `_helpers.tpl` for mapping environment variables to secret sources
- **NEVER** hardcode secret references directly in deployment templates
- Maintain one-to-many mappings where a single secret can serve multiple environment variables
- Example mapping pattern: `MAPS_API_V3_JWT_SECRET: cartoSecrets.jwtApiSecret`
- Update the central registry when adding new secrets or environment variables

### External Secret Support
- **ALWAYS** support both direct values and external secret references for every secret
- Use `existingSecret.name` and `existingSecret.key` pattern for external secrets
- When external secrets are configured, skip creating chart-managed Secret objects
- Implement proper fallback logic: external secret takes precedence over direct values

## Secret Generation and Template Patterns

### Chart-Managed Secrets
- Use `carto._utils.generateSecretObjects` function for creating Kubernetes Secret data
- **ALWAYS** base64 encode secret values using `| b64enc | quote`
- Generate secrets only when direct values are provided (not external secrets)
- Follow naming conventions: `{{ include "carto.componentName.secretName" . }}`

### Secret Resolution Process
- Parse secret paths using regex to extract group (`cartoSecrets`/`appSecrets`) and entry name
- Navigate values structure programmatically: `get $context.Values $secretGroupName`
- Extract configuration including value, existingSecret.name, and existingSecret.key
- Generate appropriate output based on configuration type (direct value vs external reference)

### Environment Variable Injection
- Use **dual injection pattern**: combine `env` and `envFrom` sections
- `env` section for external secrets requiring `valueFrom.secretKeyRef`
- `envFrom` section for bulk loading of chart-managed ConfigMaps and Secrets
- Include both ConfigMap and Secret references in envFrom when applicable

## Security and Best Practices

### Principle of Least Privilege
- Each component should only receive secrets it specifically needs
- Group secrets logically by component responsibility
- Avoid exposing platform-wide secrets to components that don't require them
- Document secret usage and justify each secret assignment

### Change Detection and Pod Restarts
- **ALWAYS** implement checksum annotations for automatic pod restarts on configuration changes
- Include checksums for: `checksum/config`, `checksum/secret`, `checksum/postgresql-password`
- Use `{{ include (print $.Template.BasePath "/component/configmap.yaml") . | sha256sum }}`
- Track external dependencies with custom checksum functions

### Secret Isolation and Management
- Chart-managed secrets are base64 encoded and never appear in plain text in templates
- External secrets are referenced by name and key only - chart never sees actual values
- Implement conditional secret loading - only create Secret objects when needed
- Support secret rotation through automatic pod restart mechanisms

## Configuration Management Patterns

### ConfigMap vs Secret Separation
- **ConfigMaps**: Non-sensitive configuration (NODE_ENV, log levels, service URLs, feature flags)
- **Secrets**: Sensitive data (passwords, API keys, tokens, certificates)
- Use helper functions for computed configuration (database hosts, service URLs)
- Implement conditional configuration based on feature flags

### Template Organization
- Separate ConfigMap and Secret templates for each component
- Use consistent naming patterns: `component/configmap.yaml` and `component/secret.yaml`
- Include both templates in deployment envFrom sections
- Maintain clear separation between sensitive and non-sensitive data

## Advanced Patterns and Features

### Secret Sharing Across Components
- Multiple environment variables can reference the same secret source
- Example: `jwtApiSecret` used by MAPS_API_V3_JWT_SECRET, WORKSPACE_JWT_SECRET, LDS_JWT_SECRET
- Implement shared secrets for platform-wide authentication and encryption
- Document secret sharing relationships and dependencies

### External ConfigMap Support
- Provide `existingConfigMap` option for each component
- Use helper functions to determine ConfigMap name: chart-managed vs external
- Pattern: `{{ .Values.component.existingConfigMap | default (include "carto.component.fullname" .) }}`
- Support migration from chart-managed to external configuration

### Service-to-Service Communication
- Use helper functions for internal service URLs: `{{ include "carto.litellm.internalUrl" . }}`
- Reuse authentication secrets for service-to-service communication
- Example: AI API uses LiteLLM master key for internal communication
- Maintain consistent URL patterns and port references

## Troubleshooting and Debugging

### Secret Resolution Debugging Steps
1. Verify environment variable exists in `carto._utils.secretAssociation`
2. Check secret path exists in values.yaml structure
3. Confirm value or existingSecret configuration is present
4. Validate secret appears in generated Secret object
5. Check pod environment variables and secret mounts

### Common Issues and Solutions
- **Secret not appearing**: Check secret association mapping and values.yaml path
- **Pod not restarting**: Verify checksum annotations are updating
- **Authentication errors**: Validate external secret references and key names
- **Template errors**: Ensure proper regex parsing and value navigation

### Validation Patterns
- Test secret resolution with different value configurations
- Verify external secret references work correctly
- Validate checksum annotations trigger pod restarts
- Confirm secret isolation between components

## Implementation Guidelines

### When Adding New Secrets
1. Add mapping to `carto._utils.secretAssociation` in `_helpers.tpl`
2. Update values.yaml with appropriate secret structure
3. Add secret to component's secret generation list
4. Include in deployment envFrom or env sections
5. Add checksum annotation for change detection

### When Modifying Existing Secrets
- Maintain backward compatibility with existing configurations
- Update documentation for secret usage changes
- Test both direct value and external secret configurations
- Verify checksum annotations still function correctly

### Code Review Checklist
- [ ] Secret association mapping exists and is correct
- [ ] Both direct value and external secret patterns supported
- [ ] Checksum annotations implemented for change detection
- [ ] Principle of least privilege followed
- [ ] ConfigMap vs Secret separation maintained
- [ ] Helper functions used for computed values
- [ ] External ConfigMap/Secret support included
- [ ] Template naming conventions followed
