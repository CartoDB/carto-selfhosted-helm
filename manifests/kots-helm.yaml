apiVersion: kots.io/v1beta2
kind: HelmChart
metadata:
  name: carto
  annotations:
    kots.io/exclude: "true"
spec:
  chart:
    name: carto
    chartVersion: 1.132.2
  builder:
    replicated:
      enabled: true
    internalPostgresql:
      enabled: false
  values:
    global:
      imagePullSecrets:
        - '{{repl ImagePullSecretName }}'
    replicated:
      imagePullSecrets:
        - name: '{{repl ImagePullSecretName }}'
      enabled: true
      platformDistribution: '{{repl ConfigOption "platformDistribution" }}'
    # License
    ## Carto Secrets
    cartoSecrets:
      encryptionSecretKey:
        value: '{{repl ConfigOption "databaseEncryptionKey" }}'
      jwtApiSecret:
        value: '{{repl ConfigOption "jwtEncryptionKey" }}'
      varnishDebugSecret:
        value: '{{repl ConfigOption "autogeneratedVarnishDebugSecret" }}'
      varnishPurgeSecret:
        value: '{{repl ConfigOption "autogeneratedVarnishPurgeSecret" }}'
      launchDarklySdkKey:
        value: '{{repl LicenseFieldValue "cartoFeaturesFlagSdkKey" }}'
      defaultGoogleServiceAccount:
        value: '{{repl ConfigOption "cartoPlatformGoogleSA" }}'
      instanceId:
        value: '{{repl ConfigOption "autogeneratedInstanceId" }}'
      vitallyToken:
        value: '{{repl LicenseFieldValue "vitallyToken" }}'
    # Carto Config Values
    cartoConfigValues:
      cartoAccApiDomain: '{{repl fromJson (ConfigOption "valuesDerivedFromCartoPlatformEnvironment") | dig "cartoAccApiDomain" "" | Base64Decode }}'
      cartoAccGcpProjectId: '{{repl fromJson (ConfigOption "valuesDerivedFromCartoPlatformEnvironment") | dig "cartoAccGcpProjectId" "" | Base64Decode }}'
      cartoAccGcpProjectRegion: '{{repl fromJson (ConfigOption "valuesDerivedFromCartoPlatformEnvironment") | dig "cartoAccGcpProjectRegion" "" | Base64Decode }}'
      cartoAuth0ClientId: '{{repl LicenseFieldValue "cartoAuthClientId" }}'
      cartoAuth0CustomDomain: '{{repl fromJson (ConfigOption "valuesDerivedFromCartoPlatformEnvironment") | dig "cartoAuth0CustomDomain" "" | Base64Decode }}'
      selfHostedTenantId: '{{repl LicenseFieldValue "selfHostedId" }}'
      launchDarklyClientSideId: '{{repl LicenseFieldValue "cartoFeaturesFlagSdkKey" }}'
      selfHostedGcpProjectId: '{{repl (ConfigOption "derivedSelfHostedGCPProjectId") }}'
      enableErrorResponseStackTrace: "false"
      cartoDataWarehouseEnabled: '{{repl ConfigOptionEquals "enableCDW" "1" }}'
      cartoSelfhostedDwLocation: '{{repl LicenseFieldValue "cartoDWLocation" }}'
      dataObservatoryProjectId: '{{repl fromJson (ConfigOption "valuesDerivedFromCartoPlatformEnvironment") | dig "dataObservatoryProjectId" "" | Base64Decode }}'
      ingressTestingMode: repl{{ if ConfigOptionEquals "enableIngressTestingMode" "1"}}truerepl{{ else }}falserepl{{ end }}
      onlyRunRouter: repl{{ if ConfigOptionEquals "enableIngressTestingMode" "1"}}truerepl{{ else }}falserepl{{ end }}
    # Customizations
    ## App Secrets
    appSecrets:
      googleMapsApiKey:
        value: '{{repl ConfigOption "googleMapsAPIKey" }}'
      bigqueryOauth2ClientSecret:
        value: '{{repl ConfigOption "bigqueryOauthClientSecret" }}'
      awsAccessKeyId:
        value: '{{repl ConfigOption "storageBucketsAwsAccessKeyId" }}'
      awsAccessKeySecret:
        value: '{{repl ConfigOption "storageBucketsAwsAccessKeySecret" }}'
      azureStorageAccessKey:
        value: '{{repl ConfigOption "storageBucketsAzureAccessKey" }}'
      azureStorageAccount:
        value: '{{repl ConfigOption "storageBucketsAzureStorageAccount"}}'
    ## App Config Values
    appConfigValues:
      # domain
      selfHostedDomain: '{{repl ConfigOption "cartoSelfHostedDomain" }}'
      # buckets
      storageProvider: '{{repl fromJson (ConfigOption "storageBucketsProvider") | dig "provider" "" }}'
      workspaceImportsBucket: '{{repl ConfigOption "storageBucketsWorkspaceImports" }}'
      workspaceImportsPublic: false
      workspaceThumbnailsBucket: '{{repl ConfigOption "storageBucketsThumbnails" }}'
      workspaceThumbnailsPublic: repl{{ if ConfigOptionEquals "storageBucketsThumbnailsIsPublic" "1"}}truerepl{{ else }}falserepl{{ end }}
      googleCloudStorageProjectId: '{{repl ConfigOption "storageBucketsGcpProjectId" }}'
      awsS3Region: '{{repl ConfigOption "storageBucketsAwsS3Region" }}'
      # other config
      bigqueryOauth2ClientId: '{{repl ConfigOption "bigqueryOauthClientID" }}'
    ## Postgresql
    internalPostgresql:
      # Disable the internal Postgres
      enabled: false
    externalPostgresql:
      host: '{{repl ConfigOption "metadataDBHost" }}'
      port: '{{repl ConfigOption "metadataDBPort" }}'
      database: '{{repl ConfigOption "metadataDBName" }}'
      user: '{{repl ConfigOption "metadataDBUser" }}'
      password: '{{repl ConfigOption "metadataDBPassword" }}'
      sslEnabled: repl{{ if ConfigOptionEquals "metadataDBSSLMode" "1"}}truerepl{{ else }}falserepl{{ end }}
      sslCA: |
        repl{{- ConfigOptionData "metadataDBSSLCertificate" | nindent 8 }}
    ## Redis
    internalRedis:
      enabled: repl{{ if ConfigOptionEquals "externalRedisEnabled" "0"}}truerepl{{ else }}falserepl{{ end }}
      auth:
        password: '{{repl ConfigOption "autogeneratedInternalRedisPassword" }}'
    externalRedis:
      host: '{{repl ConfigOption "externalRedisHost" }}'
      port: '{{repl ConfigOption "externalRedisPort" }}'
      password: '{{repl ConfigOption "externalRedisPassword" }}'
      tlsEnabled: repl{{ if ConfigOptionEquals "externalRedisTLSBehaviour" "tls_enabled"}}truerepl{{ else }}falserepl{{ end }}
      tlsCA: |
        repl{{- ConfigOptionData "externalRedisTLSCertificate" | nindent 8 }}
    ## TLS Certs
    # FIXME: Deprecated in favor of router.tlsCertificates and gateway.tlsCertificates
    # Disable legacy tlsCerts
    tlsCerts:
      httpsEnabled: repl{{ if ConfigOptionEquals "cartoRouterHTTPSEnabled" "true"}}truerepl{{ else }}falserepl{{ end }}
      autoGenerate: false
    gateway:
      enabled: repl{{ if ConfigOptionEquals "kubernetesGatewayEnabled" "true"}}truerepl{{ else }}falserepl{{ end }}
      gatewayClassName: '{{repl fromJson (ConfigOption "loadBalancerSupportedKind") | dig "gatewayClassName" "" }}'
      tlsCertificates:
        managedCerts:
          ## FIXME: api-gateway does not support yet a managed cert created in kubernetes. Can only pass pass the managed cert name, but if we create it
          ## from kubernetes this name is random. We could obtain it with the following lookup function, but the first apply wouldn't work.
          ## So at this moment, we need the customer create the managed cert himself and pass the name in this field
          ## (Lookup "networking.gke.io/v1" "ManagedCertificate" "agonzalez-kots" "carto-gateway-managed-cert").status.certificateName
          enabled: repl{{ if ConfigOptionEquals "SSLCertificatesGCP" "true"}}truerepl{{ else }}falserepl{{ end }}
          name: '{{repl ConfigOption "accessToCartoGCPExternallyManagedCertsName" }}'
      staticIP:
        enabled: repl{{ if ConfigOptionEquals "accessToCartoGCPStaticIPName" ""}}falserepl{{ else }}truerepl{{ end }}
        value: '{{repl ConfigOption "accessToCartoGCPStaticIPName" }}'
    accountsWww:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    importApi:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    importWorker:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    ldsApi:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    mapsApi:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    sqlWorker:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    router:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    httpCache:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    notifier:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    cdnInvalidatorSub:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    workspaceApi:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    workspaceSubscriber:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    workspaceWww:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    workspaceMigrations:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    tenantRequirementsChecker:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    routerMetrics:
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
    upgradeCheck:
      enabled: false
      image:
        registry: '{{repl HasLocalRegistry | ternary LocalRegistryHost "registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-onprem-artifacts" }}'
  # Optional Values
  ## Values from Advanced Configuration
  optionalValues:
    ## TEMPORAL PATCHED IMAGES
    # - when: 'true'
    #   recursiveMerge: true
    #   values:
    #     routerMetrics:
    #       image:
    #         registry: registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-artifacts
    #         tag: "latest"
    #     httpCache:
    #       image:
    #         registry: registry.self-hosted.carto.com/proxy/carto/gcr.io/carto-artifacts
    #         tag: "latest"

    ## Specify service account if workload identity is disabled
    - when: '{{repl ConfigOptionEquals "enableGoogleWorkloadIdentity" "0" }}'
      recursiveMerge: true
      values:
        appSecrets:
          googleCloudStorageServiceAccountKey:
            value: '{{repl ConfigOption "cartoPlatformGoogleSA" }}'
    ## LDS configuration
    ### LDS Geocoding, Isoline and Routing providers
    - when: '{{repl not (empty (ConfigOption "ldsGeocodingProvider")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          ldsGeocodingProvider: '{{repl ConfigOption "ldsGeocodingProvider" }}'
    - when: '{{repl not (empty (ConfigOption "ldsIsolineProvider")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          ldsIsolineProvider: '{{repl ConfigOption "ldsIsolineProvider" }}'
    - when: '{{repl not (empty (ConfigOption "ldsRoutingProvider")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          ldsRoutingProvider: '{{repl ConfigOption "ldsRoutingProvider" }}'
    ### LDS providers credentials
    - when: '{{repl not (empty (ConfigOption "ldsTomtomApiKey")) }}'
      recursiveMerge: true
      values:
        appSecrets:
          ldsTomTomApiKey:
            value: '{{repl ConfigOption "ldsTomtomApiKey" }}'
    - when: '{{repl not (empty (ConfigOption "ldsTravelTimeAppId")) }}'
      recursiveMerge: true
      values:
        appSecrets:
          ldsTravelTimeAppId:
            value: '{{repl ConfigOption "ldsTravelTimeAppId" }}'
    - when: '{{repl not (empty (ConfigOption "ldsTravelTimeApiKey")) }}'
      recursiveMerge: true
      values:
        appSecrets:
          ldsTravelTimeApiKey:
            value: '{{repl ConfigOption "ldsTravelTimeApiKey" }}'
    - when: '{{repl not (empty (ConfigOption "ldsHereApiKey")) }}'
      recursiveMerge: true
      values:
        appSecrets:
          ldsHereApiKey:
            value: '{{repl ConfigOption "ldsHereApiKey" }}'
    - when: '{{repl not (empty (ConfigOption "ldsMapboxApiKey")) }}'
      recursiveMerge: true
      values:
        appSecrets:
          ldsMapboxApiKey:
            value: '{{repl ConfigOption "ldsMapboxApiKey" }}'
    - when: '{{repl not (empty (ConfigOption "ldsGoogleApiKey")) }}'
      recursiveMerge: true
      values:
        appSecrets:
          ldsGoogleApiKey:
            value: '{{repl ConfigOption "ldsGoogleApiKey" }}'
    ## BigQuery exports
    - when: '{{repl not (empty (ConfigOption "storageBucketsExportGcp"))}}'
      recursiveMerge: true
      values:
        appConfigValues:
          workspaceExportsBucket: '{{repl ConfigOption "storageBucketsExportGcp" }}'
    ## Redshift imports
    - when: '{{repl not (empty (ConfigOption "storageBucketsImportExportAwsArnRole")) }}'
      recursiveMerge: true
      values:
        appSecrets:
          importAwsAccessKeyId:
            value: '{{repl ConfigOption "storageBucketsAwsAccessKeyId" }}'
          importAwsSecretAccessKey:
            value: '{{repl ConfigOption "storageBucketsAwsAccessKeySecret" }}'
        appConfigValues:
          importAwsRoleArn: '{{repl ConfigOption "storageBucketsImportExportAwsArnRole" }}'
    ## Snowflake and Redshift exports
    - when: '{{repl not (empty (ConfigOption "storageBucketsExportAws")) }}'
      recursiveMerge: true
      values:
        appSecrets:
          exportAwsSecretAccessKey:
            value: '{{repl ConfigOption "storageBucketsAwsAccessKeySecret" }}'
          exportAwsAccessKeyId:
            value: '{{repl ConfigOption "storageBucketsAwsAccessKeyId" }}'
        appConfigValues:
          exportAwsRoleArn: '{{repl ConfigOption "storageBucketsImportExportAwsArnRole" }}'
          awsExportBucket: '{{repl ConfigOption "storageBucketsExportAws" }}'
          awsExportBucketRegion: '{{repl ConfigOption "storageBucketsAwsS3Region" }}'
    ## ---- Router ----
    ## Terminate TLS at router
    ## Access to Carto
    # Router
    - when: '{{repl ConfigOptionEquals "customRouterSSLCerts" "true" }}'
      recursiveMerge: true
      values:
        router:
          tlsCertificates:
            certificateValueBase64: '{{repl ConfigOption "accessToCartoCustomTLSCertFile" }}'
            privateKeyValueBase64: '{{repl ConfigOption "accessToCartoCustomTLSKeyFile" }}'
    ## Open the ports on all nodes
    - when: '{{repl ConfigOptionEquals "isEmbeddedCluster" "true" }}'
      recursiveMerge: true
      values:
        router:
          service:
            type: NodePort
            nodePorts:
              http: 80
              https: 443
    ## EKS
    - when: '{{repl and (ConfigOptionEquals "accessToCartoModeK8s" "accessToCartoModeK8sDefault") (ConfigOptionEquals "platformDistribution" "eks") }}'
      recursiveMerge: true
      values:
        router:
          service:
            type: LoadBalancer
            annotations:
              service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
              service.beta.kubernetes.io/aws-load-balancer-ssl-cert: '{{repl ConfigOption "accessToCartoAWSExternallyManagedCertsName" }}'
              service.beta.kubernetes.io/aws-load-balancer-ssl-ports: https
              service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "605"
              service.beta.kubernetes.io/aws-load-balancer-scheme: internet-facing
            ports:
              httpsTargetPort: http
    # Assign static ip if specified
    - when: '{{repl and (ConfigOptionEquals "accessToCartoModeK8s" "accessToCartoModeK8sDefault") (ConfigOptionEquals "platformDistribution" "eks") (not (empty (ConfigOption "accessToCartoAWSStaticIPName"))) }}'
      recursiveMerge: true
      values:
        router:
          service:
            annotations:
              service.beta.kubernetes.io/aws-load-balancer-eip-allocations: '{{repl ConfigOption "accessToCartoAWSStaticIPName" }}'
    # Workload Identity Connection
    - when: '{{repl ConfigOptionEquals "enableBigqueryWorkloadIdentityConnection" "1" }}'
      ## ---- End router ----

      recursiveMerge: true
      values:
        appConfigValues:
          workloadIdentityConnection:
            enabled: true
            workflowsTempLocation: '{{repl ConfigOption "bigqueryWorkloadIdentityConnectionWorkflowTMP" }}'
            billingProject: '{{repl ConfigOption "bigqueryWorkloadIdentityConnectionBillingProject" }}'
            serviceAccountEmail: '{{repl ConfigOption "googleWorkloadIdentityEmail" }}'
            connectionOwner: '{{repl ConfigOption "bigqueryWorkloadIdentityConnectionOwnerId" }}'
    # Proxy
    - when: '{{repl and (ConfigOptionEquals "externalProxyEnabled" "1") (not (empty HTTPProxy)) }}'
      recursiveMerge: true
      values:
        externalProxy:
          enabled: true
          connectionString: '{{repl ConfigOption "externalProxyHost" }}'
          excludedDomains: '{{repl ConfigOption "externalProxyExcludedDomains" }}'
          sslRejectUnauthorized: repl{{ if ConfigOptionEquals "externalHttpsProxySslCertificateCheck" "0"}}falserepl{{ else }}truerepl{{ end }}
          sslCAConfigmapName: '{{repl ConfigOption "externalProxyCAConfigmapName" }}'
    - when: '{{repl ConfigOptionEquals "ssoEnabled" "1"}}'
      recursiveMerge: true
      values:
        appConfigValues:
          ssoOrganizationId: '{{repl ConfigOption "ssoOrganizationId" }}'
    # High Availability Enable
    - when: '{{repl ConfigOptionEquals "enablePlatformHighAvailability" "1" }}'
      recursiveMerge: true
      values:
        importApi:
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 1
                  podAffinityTerm:
                    labelSelector:
                      matchExpressions:
                        - key: "app.kubernetes.io/component"
                          operator: In
                          values:
                            - import-api
                    topologyKey: "kubernetes.io/hostname"
          autoscaling: &highAvailabilityEnabled
            enabled: true
            minReplicas: '{{repl ConfigOption "highAvailabilityMinReplicas" }}'
            maxReplicas: '{{repl ConfigOption "highAvailabilityMaxReplicas" }}'
        ldsApi:
          autoscaling: *highAvailabilityEnabled
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 1
                  podAffinityTerm:
                    labelSelector:
                      matchExpressions:
                        - key: "app.kubernetes.io/component"
                          operator: In
                          values:
                            - lds-api
                    topologyKey: "kubernetes.io/hostname"
        mapsApi:
          autoscaling: *highAvailabilityEnabled
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 1
                  podAffinityTerm:
                    labelSelector:
                      matchExpressions:
                        - key: "app.kubernetes.io/component"
                          operator: In
                          values:
                            - maps-api
                    topologyKey: "kubernetes.io/hostname"
        router:
          autoscaling: *highAvailabilityEnabled
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 1
                  podAffinityTerm:
                    labelSelector:
                      matchExpressions:
                        - key: "app.kubernetes.io/component"
                          operator: In
                          values:
                            - router
                    topologyKey: "kubernetes.io/hostname"
        workspaceApi:
          autoscaling: *highAvailabilityEnabled
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 1
                  podAffinityTerm:
                    labelSelector:
                      matchExpressions:
                        - key: "app.kubernetes.io/component"
                          operator: In
                          values:
                            - workspace-api
                    topologyKey: "kubernetes.io/hostname"
        workspaceWww:
          autoscaling: *highAvailabilityEnabled
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 1
                  podAffinityTerm:
                    labelSelector:
                      matchExpressions:
                        - key: "app.kubernetes.io/component"
                          operator: In
                          values:
                            - workspace-www
                    topologyKey: "kubernetes.io/hostname"
        accountsWww:
          autoscaling: *highAvailabilityEnabled
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 1
                  podAffinityTerm:
                    labelSelector:
                      matchExpressions:
                        - key: "app.kubernetes.io/component"
                          operator: In
                          values:
                            - accounts-www
                    topologyKey: "kubernetes.io/hostname"
        httpCache:
          # Note that we calculate the varnish_size as 75% of the container requests.memory
          # We know that the limit should be the double value that the varnish_size
          # https://varnish-cache.org/docs/6.0/users-guide/sizing-your-cache.html
          # Default values:
          # requests.memory = 2048Mi
          # requests.limit will be -> 3072Mi
          # varnish_size will be -> 1536Mi
          resources:
            limits:
              memory: '{{repl (Div (Mult (ConfigOption "highAvailabilityCacheMemoryRequest" | ParseInt) 3) 2)}}Mi'
              cpu: '{{repl (Mult (ConfigOption "highAvailabilityCacheCPURequest" | ParseInt) 2 )}}m'
            requests:
              memory: '{{repl (ConfigOption "highAvailabilityCacheMemoryRequest") }}Mi'
              cpu: '{{repl (ConfigOption "highAvailabilityCacheCPURequest") }}m'
    ## Custom AT location
    - when: '{{repl not (empty (ConfigOption "defaultATLocationBigQuery")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          defaultAtLocation:
            bigquery: '{{repl ConfigOption "defaultATLocationBigQuery" }}'
    - when: '{{repl not (empty (ConfigOption "defaultATLocationSnowflake")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          defaultAtLocation:
            snowflake: '{{repl ConfigOption "defaultATLocationSnowflake" }}'
    - when: '{{repl not (empty (ConfigOption "defaultATLocationRedshift")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          defaultAtLocation:
            redshift: '{{repl ConfigOption "defaultATLocationRedshift" }}'
    - when: '{{repl not (empty (ConfigOption "defaultATLocationPostgres")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          defaultAtLocation:
            postgres: '{{repl ConfigOption "defaultATLocationPostgres" }}'
    ## Custom DO location
    - when: '{{repl not (empty (ConfigOption "defaultDOLocationBigQuery")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          defaultDoLocation:
            bigquery: '{{repl ConfigOption "defaultDOLocationBigQuery" }}'
    - when: '{{repl not (empty (ConfigOption "defaultDOLocationSnowflake")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          defaultDoLocation:
            snowflake: '{{repl ConfigOption "defaultDOLocationSnowflake" }}'
    - when: '{{repl not (empty (ConfigOption "defaultDOLocationRedshift")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          defaultDoLocation:
            redshift: '{{repl ConfigOption "defaultDOLocationRedshift" }}'
    - when: '{{repl not (empty (ConfigOption "defaultDOLocationPostgres")) }}'
      recursiveMerge: true
      values:
        appConfigValues:
          defaultDoLocation:
            postgres: '{{repl ConfigOption "defaultDOLocationPostgres" }}'
    # Debug mode
    - when: '{{repl ConfigOptionEquals "enablePlatformDebugMode" "1" }}'
      recursiveMerge: true
      values:
        httpCache:
          extraEnvVars:
            - name: VARNISH_LOG_LEVEL
              value: "DEBUG"
        importApi:
          extraEnvVars:
            - name: CARTO_TRACING_MODE
              value: "local"
        importWorker:
          extraEnvVars:
            - name: CARTO_TRACING_MODE
              value: "local"
        ldsApi:
          extraEnvVars:
            - name: CARTO_TRACING_MODE
              value: "local"
        mapsApi:
          extraEnvVars:
            - name: CARTO_TRACING_MODE
              value: "local"
        sqlWorker:
          extraEnvVars:
            - name: CARTO_TRACING_MODE
              value: "local"
        workspaceApi:
          extraEnvVars:
            - name: CARTO_TRACING_MODE
              value: "local"
        workspaceSubscriber:
          extraEnvVars:
            - name: CARTO_TRACING_MODE
              value: "local"
    ## Openshift
    - when: '{{repl ConfigOptionEquals "platformDistribution" "openShift" }}'
      recursiveMerge: true
      values:
        accountsWww: &customSecurityContext
          # By not explicitly setting PodSecurityContext and ContainerSecurityContext
          #   OpenShift sets a random uid (1000700000/10000) with permissions
          podSecurityContext:
            enabled: false
          containerSecurityContext:
            enabled: false
        importApi: *customSecurityContext
        importWorker: *customSecurityContext
        ldsApi: *customSecurityContext
        mapsApi: *customSecurityContext
        sqlWorker: *customSecurityContext
        router: *customSecurityContext
        routerMetrics: *customSecurityContext
        httpCache: *customSecurityContext
        notifier: *customSecurityContext
        cdnInvalidatorSub: *customSecurityContext
        workspaceApi: *customSecurityContext
        workspaceSubscriber: *customSecurityContext
        workspaceWww: *customSecurityContext
        workspaceMigrations: *customSecurityContext
        tenantRequirementsChecker: *customSecurityContext
        internalPostgresql: *customSecurityContext
        upgradeCheck: *customSecurityContext
    # GKE Workload Identity
    - when: '{{repl ConfigOptionEquals "enableGoogleWorkloadIdentity" "1" }}'
      recursiveMerge: true
      values:
        commonBackendServiceAccount:
          enableGCPWorkloadIdentity: true
          # When enabling gke workload identity, the k8s SA should be created by the customer to be able to run preflights
          create: false
          name: '{{repl ConfigOption "k8sWorkloadIdentityServiceAccountName" }}'
    # Local Registry
    - when: '{{repl (HasLocalRegistry) }}'
      recursiveMerge: true
      values:
        global:
          imageRegistry: '{{repl LocalRegistryAddress }}'
          imagePullSecrets:
            - '{{repl ImagePullSecretName }}'
        replicated:
          imagePullSecrets:
            - name: '{{repl ImagePullSecretName }}'
          images:
            replicated-sdk: '{{repl LocalImageName "docker.io/replicated/replicated-sdk:v1.0.0-beta.21" }}'
    # THIS SHOULD ALWAYS BE THE LAST OPTIONAL VALUE!!!!
    ## Advanced Tuning
    - when: '{{repl not (empty (ConfigOption "platformAdvancedTuningValues")) }}'
      recursiveMerge: true
      values: repl{{ ConfigOption "platformAdvancedTuningValues" | nindent 8 }}
