apiVersion: kots.io/v1beta2
kind: HelmChart
metadata:
  name: carto
  annotations:
    kots.io/exclude: "true"
spec:
  chart:
    name: carto
    chartVersion: 1.77.1
  values:
    replicated:
      enabled: true
      platformDistribution: '{{repl ConfigOption "platformDistribution" }}'
      # TODO: To be removed when https://app.shortcut.com/cartoteam/story/383961/delete-podsecuritycontext-from-replicated-sdk-when-they-release-a-version-with-the-security-context-updated
      # is done
      podSecurityContext:
        enabled: true
        fsGroup: 1001
        runAsUser: 1001
        runAsGroup: 1001
        supplementalGroups:
          - 1001
        seccompProfile:
          type: "RuntimeDefault"

    # License
    ## Carto Secrets
    cartoSecrets:
      encryptionSecretKey:
        value: '{{repl ConfigOption "kotsEncryptionSecretKey" }}'
      jwtApiSecret:
        value: '{{repl ConfigOption "kotsVarnishDebugSecret" }}'
      varnishDebugSecret:
        value: '{{repl ConfigOption "kotsJwtApiSecret" }}'
      varnishPurgeSecret:
        value: '{{repl ConfigOption "kotsVarnishPurgeSecret" }}'
      launchDarklySdkKey:
        value: '{{repl LicenseFieldValue "cartoFeaturesFlagSdkKey" }}'
      defaultGoogleServiceAccount:
        value: '{{repl ConfigOption "cartoPlatformGoogleSA" }}'
    # Carto Config Values
    cartoConfigValues:
      cartoAccApiDomain: '{{repl fromJson (ConfigOption "environmentCustomerPackageValues") | dig "cartoAccApiDomain" "" | Base64Decode }}'
      cartoAccGcpProjectId: '{{repl fromJson (ConfigOption "environmentCustomerPackageValues") | dig "cartoAccGcpProjectId" "" | Base64Decode }}'
      cartoAccGcpProjectRegion: '{{repl fromJson (ConfigOption "environmentCustomerPackageValues") | dig "cartoAccGcpProjectRegion" "" | Base64Decode }}'
      cartoAuth0ClientId: '{{repl LicenseFieldValue "cartoAuthClientId" }}'
      cartoAuth0CustomDomain: '{{repl fromJson (ConfigOption "environmentCustomerPackageValues") | dig "cartoAuth0CustomDomain" "" | Base64Decode }}'
      selfHostedTenantId: '{{repl LicenseFieldValue "selfHostedId" }}'
      launchDarklyClientSideId: '{{repl fromJson (ConfigOption "environmentCustomerPackageValues") | dig "launchDarklyClientSideId" "" | Base64Decode }}'
      selfHostedGcpProjectId: '{{repl (ConfigOption "projectId") }}'
      # customerPackageVersion: ""
      enableErrorResponseStackTrace: "false"
      cartoDataWarehouseEnabled: '{{repl ConfigOptionEquals "enableCDW" "1" }}'
      cartoSelfhostedDwLocation: '{{repl LicenseFieldValue "cartoDWLocation" }}'

    # Customizations
    ## App Secrets
    appSecrets:
      googleMapsApiKey:
        value: '{{repl ConfigOption "googleMapsAPIKey" }}'
      bigqueryOauth2ClientSecret:
        value: '{{repl ConfigOption "bigqueryOauthClientSecret" }}'
      googleCloudStorageServiceAccountKey:
        value: '{{repl ConfigOption "cartoPlatformGoogleSA" }}'
      awsAccessKeyId:
        value: '{{repl ConfigOption "storageBucketsAwsAccessKeyId" }}'
      awsAccessKeySecret:
        value: '{{repl ConfigOption "storageBucketsAwsAccessKeySecret" }}'
      azureStorageAccessKey:
        value: '{{repl ConfigOption "storageBucketsAzureAccessKey" }}'
      importAwsAccessKeyId:
        value: '{{repl ConfigOption "storageBucketsImportExportAwsAccessKeyId" }}'
      importAwsSecretAccessKey:
        value: '{{repl ConfigOption "storageBucketsImportExportAwsSecretAccessKey" }}'
      exportAwsSecretAccessKey:
        value: '{{repl ConfigOption "storageBucketsImportExportAwsSecretAccessKey" }}'
      exportAwsAccessKeyId:
        value: '{{repl ConfigOption "storageBucketsImportExportAwsAccessKeyId" }}'
      ldsHereApiKey:
        value: '{{repl ConfigOption "locationDataServicesHereCredentials" }}'
      ldsTomTomApiKey:
        value: '{{repl ConfigOption "locationDataServicesTomtomCredentials" }}'
      ldsGoogleApiKey:
        value: '{{repl ConfigOption "locationDataServicesGoogleCredentials" }}'
      ldsMapboxApiKey:
        value: '{{repl ConfigOption "locationDataServicesMapboxCredentials" }}'
      ldsTravelTimeAppId:
        value: '{{repl ConfigOption "locationDataServicesTraveltimeAppId" }}'
      ldsTravelTimeApiKey:
        value: '{{repl ConfigOption "locationDataServicesTraveltimeApiKey" }}'
    ## App Config Values
    appConfigValues:
      # domain
      selfHostedDomain: '{{repl ConfigOption "cartoSelfhostedDomain" }}'
      # buckets
      storageProvider: '{{repl fromJson (ConfigOption "storageBucketsProvider") | dig "provider" "" }}'
      workspaceImportsBucket: '{{repl ConfigOption "storageBucketsWorkspaceImports" }}'
      workspaceImportsPublic: repl{{ if ConfigOptionEquals "storageBucketsWorkspaceImportsIsPublic" "public"}}truerepl{{ else }}falserepl{{ end }}
      workspaceThumbnailsBucket: '{{repl ConfigOption "storageBucketsThumbnails" }}'
      workspaceThumbnailsPublic: repl{{ if ConfigOptionEquals "storageBucketsThumbnailsIsPublic" "public"}}truerepl{{ else }}falserepl{{ end }}
      workspaceExportsBucket: '{{repl ConfigOption "storageBucketsWorkspaceExports" }}'
      googleCloudStorageProjectId: '{{repl ConfigOption "storageBucketsGcpProjectId" }}'
      awsS3Region: '{{repl ConfigOption "storageBucketsAwsS3Region" }}'
      importAwsRoleArn: '{{repl ConfigOption "storageBucketsImportExportAwsArnRole" }}'
      awsExportBucket: '{{repl ConfigOption "storageBucketsExportAws" }}'
      awsExportBucketRegion: '{{repl ConfigOption "storageBucketsExportAwsRegion" }}'
      exportAwsRoleArn: '{{repl ConfigOption "storageBucketsImportExportAwsArnRole" }}'
      # other config
      httpCacheEnabled: "true"
      bigqueryOauth2ClientId: '{{repl ConfigOption "bigqueryOauthClientID" }}'
      enableTrackJS: "true"
      ssoOrganizationId: ""
      defaultAtLocation:
        bigquery: "carto-un.carto"
        snowflake: "CARTO.CARTO"
        redshift: "carto"
        postgres: "carto"

    ## Postgresql
    internalPostgresql:
      # Disable the internal Postgres
      enabled: false
    externalPostgresql:
      host: '{{repl ConfigOption "metadataDBHost" }}'
      port: '{{repl ConfigOption "metadataDBPort" }}'
      database: '{{repl ConfigOption "metadataDBName" }}'
      user: '{{repl ConfigOption "metadataDBUser" }}'
      password: '{{repl ConfigOption "metadataDBPassword" }}'
      sslEnabled: repl{{ if ConfigOptionEquals "metadataDBSSLMode" "1"}}truerepl{{ else }}falserepl{{ end }}
      sslCA: |
        repl{{- ConfigOptionData "metadataDBSSLCertificate" | nindent 8 }}

    ## Redis
    internalRedis:
      enabled: repl{{ if ConfigOptionEquals "externalRedisEnabled" "0"}}truerepl{{ else }}falserepl{{ end }}
    externalRedis:
      host: '{{repl ConfigOption "externalRedisHost" }}'
      port: '{{repl ConfigOption "externalRedisPort" }}'
      password: '{{repl ConfigOption "externalRedisPassword" }}'
      tlsEnabled: repl{{ if ConfigOptionEquals "externalRedisSSLMode" "ssl_mode_enable"}}truerepl{{ else }}falserepl{{ end }}
      tlsCA: |
        repl{{- ConfigOptionData "externalRedisSSLCertificate" | nindent 8 }}

    # Service Account
    commonBackendServiceAccount:
      enableGCPWorkloadIdentity: repl{{ if ConfigOptionEquals "enableGoogleWorkloadIdentity" "1"}}truerepl{{ else }}falserepl{{ end }}
      annotations:
        iam.gke.io/gcp-service-account: '{{repl ConfigOption "googleWorkloadIdentityEmail" }}'

    ## TLS Certs
    # FIXME: Deprecated in favor of router.tlsCertificates and gateway.tlsCertificates
    # Disable legacy tlsCerts
    tlsCerts:
      httpsEnabled: false
      autoGenerate: false

    ## Access to Carto
    # Router
    router:
      service:
        type: NodePort
      httpsEnabled: repl{{ if ConfigOptionEquals "cartoRouterHTTPSEnabled" "true"}}truerepl{{ else }}falserepl{{ end }}
      tlsCertificates:
        certificateValueBase64: '{{repl ConfigOption "accessToCartoCustomTLSCertFile" }}'
        privateKeyValueBase64: '{{repl ConfigOption "accessToCartoCustomTLSKeyFile" }}'

    gateway:
      enabled: repl{{ if ConfigOptionEquals "kubernetesGatewayEnabled" "true"}}truerepl{{ else }}falserepl{{ end }}
      gatewayClassName: '{{repl fromJson (ConfigOption "loadBalancerSupportedKind") | dig "gatewayClassName" "" }}'
      tlsCertificates:
        customSSLCerts:
          enabled: repl{{ if ConfigOptionEquals "customSSLCerts" "true"}}truerepl{{ else }}falserepl{{ end }}
          certificateValueBase64: '{{repl ConfigOption "accessToCartoCustomTLSCertFile" }}'
          privateKeyValueBase64: '{{repl ConfigOption "accessToCartoCustomTLSKeyFile" }}'
        managedCerts:
          ## FIXME: api-gateway does not support yet a managed cert created in kubernetes. Can only pass pass the managed cert name, but if we create it
          ## from kubernetes this name is random. We could obtain it with the following lookup function, but the first apply wouldn't work.
          ## So at this moment, we need the customer create the managed cert himself and pass the name in this field
          ## (Lookup "networking.gke.io/v1" "ManagedCertificate" "agonzalez-kots" "carto-gateway-managed-cert").status.certificateName
          enabled: repl{{ if ConfigOptionEquals "SSLCertificatesGCP" "true"}}truerepl{{ else }}falserepl{{ end }}
          name: '{{repl ConfigOption "accessToCartoManagedCertsGCPName" }}'
      staticIP:
        enabled: repl{{ if ConfigOptionEquals "defaultLBStaticIPAddressGCP" ""}}falserepl{{ else }}truerepl{{ end }}
        value: '{{repl ConfigOption "defaultLBStaticIPAddressGCP" }}'


  # Optional Values
  ## Values from Advanced Configuration
  optionalValues:
    # START: Temporary hack to fix some images not already released
    - when: "true"
      recursiveMerge: true
      values:
        workspaceMigrations:
          image:
            tag: 20240117pr15139
    # END

    ## Router
    ## EKS
    - when: '{{repl and (ConfigOptionEquals "accessToCartoModeK8s" "accessToCartoModeK8sDefaultLB") (ConfigOptionEquals "platformDistribution" "eks") }}'
      recursiveMerge: true
      values:
        router:
          service:
            type: LoadBalancer
            annotations:
              service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
              service.beta.kubernetes.io/aws-load-balancer-ssl-cert: '{{repl ConfigOption "accessToCartoTLSCertificatesEKS" }}'
              service.beta.kubernetes.io/aws-load-balancer-ssl-ports: https
              service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "605"
              service.beta.kubernetes.io/aws-load-balancer-eip-allocations: '{{repl ConfigOption "defaultLBStaticIPAddressAWS" }}'
              service.beta.kubernetes.io/aws-load-balancer-scheme: internet-facing
            ports:
              httpsTargetPort: http

    # Workload Identity Connection
    - when: '{{repl ConfigOptionEquals "enableBigqueryWorkloadIdentityConnection" "1" }}'
      recursiveMerge: true
      values:
        appConfigValues:
          workloadIdentityConnection:
            enabled: true
            workflowsTempLocation: '{{repl ConfigOption "bigqueryWorkloadIdentityConnectionWorkflowTMP" }}'
            billingProject: '{{repl ConfigOption "bigqueryWorkloadIdentityConnectionBillingProject" }}'
            serviceAccountEmail: '{{repl ConfigOption "googleWorkloadIdentityEmail" }}'
            connectionOwner: '{{repl ConfigOption "bigqueryWorkloadIdentityConnectionOwnerId" }}'

    # Proxy
    - when: '{{repl ConfigOptionEquals "externalProxyEnabled" "1" }}'
      recursiveMerge: true
      values:
        externalProxy:
          enabled: true
          connectionString: '{{repl ConfigOption "externalProxyHost" }}'
          excludedDomains: '{{repl ConfigOption "externalProxyExcludedDomains" }}'
          sslRejectUnauthorized: repl{{ if ConfigOptionEquals "externalHttpsProxySslCertificateCheck" "0"}}falserepl{{ else }}truerepl{{ end }}
          sslCA: |
            repl{{ ConfigOptionData "externalHttpsProxySslCa" | nindent 12 }}

    # High Availability Enable
    - when: '{{repl ConfigOptionEquals "enablePlatformHighAvailability" "1" }}'
      recursiveMerge: true
      values:
        importApi: &highAvailabilityEnabled
          autoscaling:
            enabled: true
            minReplicas: '{{repl ConfigOption "highAvailabilityMinReplicas" }}'
            maxReplicas: '{{repl ConfigOption "highAvailabilityMaxReplicas" }}'
        ldsApi: *highAvailabilityEnabled
        mapsApi: *highAvailabilityEnabled
        router: *highAvailabilityEnabled
        workspaceApi: *highAvailabilityEnabled
        workspaceWww: *highAvailabilityEnabled
        accountsWww: *highAvailabilityEnabled

    ## Advanced Tuning
    - when: '{{repl ConfigOptionEquals "enablePlatformAdvancedTuning" "1" }}'
      recursiveMerge: true
      values: repl{{ ConfigOption "platformAdvancedTuningValues" | nindent 8 }}
